# Инкапсуляция - принцип ООП
> у которого есть 2 трактовки:
1. все что нужно для работы класса - лежит в классе
2. ограничение доступа к аттрибутом(сокрытие данных)

# в питоне есть 3 доступа ввида:
1. public (публичный)
2. proteccted(защищенный) - когда один underscore в начале
3. private (приватный)   - когда два underscore а начале


> В Python инкапсуляция реализованна на уровне соглашение



# Getters / Setters
> методы с помощью которых мы указываем каким образом мы можем получать и изменять какие-то аттрибуты


# Property
> декаратор  - который превращает метод в аттрибут с декаратороми getter, setter, deleter
> setter - будет работать - вызываться когда мы будем записывать в аттрибут значение
> deleter - будет работать - вызываться когда мы удаляем аттрибут через del


``` py
class A:
    @property
    def hello(self):
        return 5

    # property.setter работает когда мы пишем obj.attr = ... 
    @hello.setter
    def hello(self, new_value):
        print("setter")

    # property.deleter работает когда мы пишем del obj.attr
    @hello.deleter
    def hello(self):
        print("deleter")

obj = A()
print(obj.hello) #5
obj.hello = 'new value' #setter
del obj.hello #deleter
```

Инкапсуляция.
С помощью инкапсуляции можно ограничить доступ к атрибутам и методам внутри класса.
В Python существует три вида "защиты": публичный, защищенный и приватный.
К публичному виду относятся все элементы класса по умолчанию, то есть здесь инкапсуляция отсутсвует.
К защищенному виду относятся атрибуты и методы с одним подчеркиванем в начале названия атрибута или метода:

class A: 
  def _protected(self): 
      print('защищен') 
однако, если мы создадим объект от данного класса и вызовем метод _protected:

a = A() 
a._protected() 
то в терминале все равно получим вывод:
защищен 
Данный вид инкапсуляции, в Python, работает на уровне соглашения между разработчиками, т.е на самом деле Python, никак не скрывает и не защищает ваши методы и атрибуты.
Но вы можете поставить одно подчеркивание перед названием, чтобы дать понять другим программистам, которые будут использовать ваш код, что данный элемент изменять нельзя.
Приватные методы и атрибуты создаются двумя нижними подчеркиваниями до названия метода или атрибута.

Например:

class A: 
  def __private(self): 
      print('приватный') 
если мы создадим объект и попытаемся вызвать такой метод:

a = A() 
a.__private() 
в терминале уже получим исключение:
AttributeError: 'A' object has no attribute '__private' 

getter(геттер) - это любой метод, с помощью которого мы можем получить значение приватного атрибута
setter(сеттер) - это любой метод, с помощью которого мы можем изменить значение приватного атрибута

Для удобства, в инкапсуляции существует два декоратора:
для setters - @название.setters, 
а для getters - @property.
С помощью данных декораторов можно имитировать обычное присваивание нового значение атрибуту через знак равно и доступ к значению атрибута через точку для приватных атрибутов.
То есть они будут работать также, как будто бы и не были защищены:
obj.атрибут  
     #выведет значение  
obj.атрибут = 'hello!'  
     #установит новое значение атрибуту объекта 
Перепишем методы нашего класса Phone через данные декораторы:

class Phone: 
  def __init__(self, passcode): 
      self.__passcode = passcode 
 
  @property 
  def code(self): 
      return self.__passcode

  @code.setter 
  def code(self, new): 
      self.__passcode = new  
Обычно, Python не допускает создание функций с одинаковым названием, но в инкапсуляции для того чтобы наши декораторы работали корректно, оба метода и setter и getter должны иметь одно название.
Для декоратора @property достаточно просто добавить его над методом, который отвечает за получение значения.
Для декоратора @название.setter, в начале нужно прописать название функции, к примеру если функция называется func, то декоратор будет выглядеть таким образом - @func.setter.
Создадим объект от класса и посмотрим как применяются декорированные методы:
myphone = Phone(1234) 
print(myphone.code) 
как мы видим, для получения приватного атрибута, теперь достаточно просто указать название объекта и через точку указать название атрибута, в терминале получим:
1234 
если же мы хотим установить новое значение, делается это также как если бы мы присваивали новое значение обычному(публичному) атрибуту:
myphone.code = 4321 
print(myphone.code) 
в терминале получим:
4321 