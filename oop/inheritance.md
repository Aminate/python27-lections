# Наследование
> принцип ООП, где мы можем унаследовать,переопределять и использовать все отрибуты
и методы родительского класса

```py
class A:
    def method(self):
        print("метод в классе А")

obj_a = A()
obj_a.method()
#метод в классе А

class B(A):
    pass

obj_b = B()
obj_b.method()
#метод в классе А

> класс А - родительский
> класс Б - дочерний
# метод класса А


## Переопределение
> когда мы создаем метод или аттрибут с таким же названием, как и в родительских классах

```py

class C(A):
    def method(self):
        print("метод в классе С")

obj_c = C()
obj_c.method()
#метод в классе С
```


## Виды наследование
#основные:
* одиночное наследование(когда один родитель) например: B наследуется от А
* множественное (когда несколько родителей) С наследуется от А и B

#не основные
* многоуровневое(когда у родителей есть родители(как минимум один родитель)) 
* иерархическое(когда мы наследуемся и каждого есть один родителей, но у родителя может быть много детей)
* гибритное(когда совмещение разных видов наследование)

## проблемы множественного наследование
1 Проблема ромба (решенная с помощью MRO(с версией 2.3))
> mro - method resolution order (простраивает порядок для поиска аттрибутов)

```py

class A:
    pass
class B:
    pass
class C(A,B):
    pass
#до mro
[C,A object, C,B, object]

#после mro
[C, A, B, object]

```

1 не решенная проблема(проблема перекрестного наследование) возникает когда не возможно
простроить приоритет родителей


class A:
    pass
class B:
    pass
class C(A,B):
    pass
class D(B,A):
    pass
class  E(C,D):
    pass
    #TypeError: Cannot create a consistent method resolution
#order (MRO) for bases A, B

